// @tip_redux00
// Опа, какие люди
// Заходи, не бойся. Уходя не плачь
// Давай по частям: 
// redux это кто(who)? @tip_redux01
// Как описать состояние приложения, используя redux? @tip_redux02
// Как приебенить redux к react?? @tip_redux03
// Теперь что я от тебя хочу: 
// В существующем редьюсере ничего менять не придется
// Нужно только добавить поле type в объект , который приходит в notification (это там, где ты будешь отображать подсказку (типы можно вынести в отдельный файл рядом с компонентом)) и обрабатывать его в компоненте
// Это с уведомлениями

// Можешь доделать action-creator для сохранения данных, если хорошо зашарил за redux (это @todo_action-creator00) 

// @tip_redux01
// redux - менеджер состояний (ну тупа я после 5 лет в унике)
// нихуя из определения не понятно, хотя кажется, что понятно - это нормально
// Давай разбираться
// Какие состояния будем менеджирить?
// Ты уже пробовал писать код на react, и знаком с хуком useState, которым определял состояние компонента
// Приложение, состоящие из этих компонентов - пиздец комплексная вещь, и по-умному говоря является больше чем суммой своих компонентов (перечитай, если не понял)
// И вот в определенный момент возникает ситуация, когда тебе очень нужно определить какое-нибудь состояние для всего приложения
// (Авторизационные данные пользователя - хороший пример)
// Для этого есть несколько механизмов, redux - один из них
// Ты, вероятно, спросишь, почему бы не сделать как в шарпике - ебанул глобальную переменную на лицо и сидишь довольный
// А потому что нельзя
// В шарпике у тебя переменная лежит в одном с кодом классе и отовсюду видна
// А тут каждый компонент - отдельная самостоятельная [сильная и независимая] сущность, и каждому компоненту это значение нужно передавать от родителя
// А теперь открой DOM-дерево в браузерной консоли и охуей от масштабов даже нашего карманного проектика [а разговоров то было...]
// В общем, глобальные значения мы хотим, а передавать их ручками не хотим
// К тому же нужно определять, когда они изменятся, чтобы перерендерить компонент
// И тут на сцену выходит redux
// Он умеет хранить нужные нам значения, позволяет объединять состояния в одно и сам отлавливает момент, когда они поменяются
// [Его работу можно симитировать используя паттерн observer - почитай, полезная штука [да, я выебываюсь, и что?]]

import {combineReducers} from 'redux';
import {APPEND_NOTIFICATION, POP_NOTIFICATION, SET_AUTH_DATA, SET_DATA, SET_ITEM, SET_NOTIFICATION_DATA, SET_OPTION, RESET_ACTIVE_NOTIFICATION, NOTIFICATION_TEST} from './actions';

const optionReducer = (state = 'About', action) => {
    switch (action.type) {
        case SET_OPTION: return action.payload
        default: return state;
    }
}

const dataReducer = (state = {model: '', rows: []}, action) => {
    switch (action.type) {
        case SET_DATA: return action.payload
        default: return state
    }
}

// @example_reducer00
// В общих чертах: в redux редьюсер принимает в качестве аргументов предыдущее состояние и объект action, который указывает, что с этим состоянием делать
// ОЧЕНЬ ВАЖНО: state - предыдущее состояние - менять нельзя. Я запрещаю. Можно только на его основе построить новое состояние, которое редьюсер должен вернуть [return там и всё такое, ага]
// action - Объект, указывающий на то, каким образом нужно изменить состояние. Ты состовляешь его сам. Но в него обязательно нужно положить поле type - тип действия
// Чтобы не сильно ебаться все типы действий вынесены в отдельный файл - @example_reducer01
// Тепперь давай посмотрим в код редьюсера:
const userInfoReducer = (state = {authorizationStatus: 'non-authorized'} /*Определять начальное значение обязательно. Оно будет использовано для инициализации состояния*/, action) => {
    switch (action.type) { // Да, вот так просто. Свитч по типу действия и всё
        case SET_AUTH_DATA: return action.payload // А вот тут мы определяем новое состояние
        // Как я говорил, объект action ты формируешь сам, ну вот я и положил в него "полезную нагрузку" (payload)
        // Конкретно в этом случае в payload будет лежать уже готовое состояние
        // А вот откуда берется объект action @example_reducer02
        default: return state; // В случае, если такого действия нет, состояние вернем без изменений
    }
}
// Подведем итог редьюсер - функция, для изменения состояния. Принимает предыдушее состояние и объект action, который формируется action creator'ом. Редьюсер вызывается после вызова dispatch
// [ты пришел из @example_reducer00 в этом файле]

const itemReducer = (state = null, action) => {
    switch (action.type) {
        case SET_ITEM: {
            return action.payload;
        }
        default: return state;
    }
}

const notificationReducer = (state = { queue: [], wpm: 120, activeNotification: null}, action) => {
    switch (action.type) {
        case APPEND_NOTIFICATION: {
            const queue = [...state.queue];
            queue.push(action.payload);
            return {...state, queue};
        }
        case POP_NOTIFICATION: {
            const queue = [...state.queue];
            const activeNotification = queue.shift();
            return {...state, queue, activeNotification};
        }
        case SET_NOTIFICATION_DATA: return {...state, ...action.payload};
        case RESET_ACTIVE_NOTIFICATION: return {...state, activeNotification: null};
        case NOTIFICATION_TEST: {
            const prefabs = [
                {
                    title: 'Gay detected!', // це заголовок - должна быть строка, но можно и число - хуле нам
                    content: 'The probability that you are gay is about 78%', // это текст уведомления
                    type: 'error'
                },
                {
                    title: 'Gay detected!',
                    content: 'The probability that you are gay is about 78%'
                },
                {
                    title: 'Gay detected!',
                    type: 'success',
                    content: 'The probability that you are gay is about 78%'
                },
                {
                    title: 'Gay detected!',
                    type: 'gay',
                    content: 'The probability that you are gay is about 78%'
                }
            ];
            return {
                ...state,
                queue: prefabs,
            };
        };
        default: return state;
    }
}

// @tip_redux02
// Посередине подсказки будет код, посмотри его
// Рассмотрим определение состояния на примере авторизационных данных пользователя
// Для начала я вкратце поясню тебе за observer - ты же гей, не загуглил и не почитал, я знаю
// Смысл паттерна в том, чтобы обеспечить наблюдение за определенным значением
// Решать мы это будем, ограничивая доступ к нему
// Реализация будет выглядеть как-то так: @example_observer00
// И еще раз для итога: redux нужен, чтобы хранить глобальные значения без особой ебли, работает по принципу observer. Едем дальше
// Чтобы описать состояние нам не придется писать целый класс как в примере. Обойдемся только функцией для изменения состояния
// [Далее функцию, меняющуюю состояние будем называть редьюсером (reducer)]
// Пример описания редьюсера для авторизационных данных пользователя: @example_reducer00
// Теперь, когда у нас есть редьюсер и всё для него необходимое, мы можем включить его в список для использования:
export const rootReducer = combineReducers(
    {
        option: optionReducer,
        data: dataReducer,
        userInfo: userInfoReducer,
        selectedItem: itemReducer,
        notificationInfo: notificationReducer
    });
// Кстати говоря, вот как теперь будет выглядеть наше состояние:
// eslint-disable-next-line no-unused-vars
const stateExample = { 
    option: 'About', // Выбранная таблица
    data: { // Данные выбранной таблицы
      model: '', // Имя загруженной модели
      rows: [] // Загруженные данные
    },
    userInfo: { // Авторизационные данные пользователя
      authorizationStatus: 'non-authorized'
    },
    selectedItem: null, // Выбранный элемент таблицы
    notificationInfo: { // Всё для уведомлений
      queue: [], // Очередь на показ
      wpm: 120, // Примерная скорость чтения (words per minute), для рассчета времени отображения
      isShowing: false, // Сейчас не используется
      activeNotification: null // Уведомление, в данный момент находящееся на экране
    }
}
// Объект выше - состояние приложения после запуска
// Тут можно увидеть, что каждое отдельное состояние, для которого мы описывали редьюсер, в общем состоянии приложения находится по тому ключу, который мы определили в rootReducer
// А еще все начальные значения взяты из редьюсеров
// Таки вот. Для того, чтобы описать состояние нужно описать редьюсер, к нему пару экшнов и немножко экшн-креэйторов, засунуть редьюсер в rootReducer по какому-нибудь ключу. И всё. Не так уж сложно
// [Ты пришел из @tip_redux02 в этом файле]






// @tip_test01 
// Мяу. Как-то так это должно работать